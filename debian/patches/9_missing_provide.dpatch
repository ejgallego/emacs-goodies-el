#!/bin/sh -e
## 9_missing_provide.dpatch.dpatch by Peter S Galbraith <psg@debian.org>
##
## All lines beginning with `## DP:' are a description of the patch.
## DP: No description.

if [ $# -ne 1 ]; then
    echo >&2 "`basename $0`: script expects -patch|-unpatch as argument"
    exit 1
fi

[ -f debian/patches/00patch-opts ] && . debian/patches/00patch-opts
patch_opts="${patch_opts:--f --no-backup-if-mismatch}"

case "$1" in
       -patch) patch $patch_opts -p1 < $0;;
       -unpatch) patch $patch_opts -p1 -R < $0;;
        *)
                echo >&2 "`basename $0`: script expects -patch|-unpatch as argument"
                exit 1;;
esac

exit 0

@DPATCH@
diff -urNad /home/psg/emacs/emacs-goodies-el/emacs-goodies-el/elisp/devscripts-el/devscripts.el emacs-goodies-el/elisp/devscripts-el/devscripts.el
--- /home/psg/emacs/emacs-goodies-el/emacs-goodies-el/elisp/devscripts-el/devscripts.el	2003-06-14 21:30:49.000000000 -0400
+++ emacs-goodies-el/elisp/devscripts-el/devscripts.el	2003-06-15 21:16:11.000000000 -0400
@@ -65,3 +65,5 @@
        (modify-syntax-entry ?\" ".   " text-mode-syntax-table)
        (modify-syntax-entry ?\\ ".   " text-mode-syntax-table)
        (modify-syntax-entry ?' "w   " text-mode-syntax-table))
+
+(provide 'devscripts)
diff -urNad /home/psg/emacs/emacs-goodies-el/emacs-goodies-el/elisp/emacs-goodies-el/align-string.el emacs-goodies-el/elisp/emacs-goodies-el/align-string.el
--- /home/psg/emacs/emacs-goodies-el/emacs-goodies-el/elisp/emacs-goodies-el/align-string.el	2003-06-14 22:35:26.000000000 -0400
+++ emacs-goodies-el/elisp/emacs-goodies-el/align-string.el	2003-06-15 21:15:50.000000000 -0400
@@ -91,4 +91,6 @@
     ;; Clear end marker.
     (set-marker end nil)))
 
+(provide 'align-string)
+
 ;;; align-string.el ends here
diff -urNad /home/psg/emacs/emacs-goodies-el/emacs-goodies-el/elisp/emacs-goodies-el/align-string.el.~1.1.1.1.~ emacs-goodies-el/elisp/emacs-goodies-el/align-string.el.~1.1.1.1.~
--- /home/psg/emacs/emacs-goodies-el/emacs-goodies-el/elisp/emacs-goodies-el/align-string.el.~1.1.1.1.~	1969-12-31 19:00:00.000000000 -0500
+++ emacs-goodies-el/elisp/emacs-goodies-el/align-string.el.~1.1.1.1.~	2003-06-14 22:35:26.000000000 -0400
@@ -0,0 +1,94 @@
+;;; align-string.el --- align string components over several lines
+
+;; Copyright (c) 2001 Markus Bjartveit Krüger
+
+;; Author:   Markus Bjartveit Krüger <markusk@pvv.org>
+;; Created:  20-Sep-2001
+;; Version:  0.1
+;; Keywords: convenience
+;; X-URL:    http://www.pvv.org/~markusk/align-string.el
+
+;; This is free software; you can redistribute it and/or modify it
+;; under the terms of the GNU General Public License as published by
+;; the Free Software Foundation; either version 2, or (at your option)
+;; any later version.  This is distributed in the hope that it will be
+;; useful, but without any warranty; without even the implied warranty
+;; of merchantability or fitness for a particular purpose.  See the
+;; GNU General Public License for more details.  You should have
+;; received a copy of the GNU General Public License along with GNU
+;; Emacs; see the file `COPYING'.  If not, write to the Free Software
+;; Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+;; 02111-1307, USA.
+
+;;; Code:
+
+(defun align-string (begin end regexp count)
+  "Align first occurrence of REGEXP in each line of region.
+If given a prefix argument, align occurrence number COUNT on each line."
+  (interactive "r
+sAlign by: 
+p")
+  (save-excursion
+    ;; Move begin point to start of line.
+    (goto-char begin)
+    (setq begin (line-beginning-position))
+    ;; Make end a marker, to track updates made in buffer.  Point the
+    ;; marker at the end of the last line.
+    (goto-char end)
+    (setq end (set-marker (make-marker) (line-end-position)))
+    (let ((max-col 0))
+      ;; Find max column of first occurrence of string in the lines
+      ;; bounded by begin-marker and end-marker
+      (goto-char begin)
+      (while (< (point) end)
+	(when (re-search-forward regexp (line-end-position) t count)
+	  (goto-char (match-beginning 0))
+	  (setq max-col (max (current-column) max-col)))
+	(beginning-of-line 2))
+      ;; For each line in region, indent first occurrence of string
+      ;; to max column.
+      (goto-char begin)
+      (while (< (point) end)
+	(when (re-search-forward regexp (line-end-position) t count)
+	  (goto-char (match-beginning 0))
+	  (indent-to max-col))
+	(beginning-of-line 2)))
+    ;; Clear end marker.
+    (set-marker end nil)))
+
+(defun align-all-strings (begin end regexp)
+  "Align all occurrences of REGEXP in each line of region.
+That is to say, align the first occurrence of each line with each other,
+align the second occurence of each line with each other, and so on."
+  (interactive "r
+sAlign by: ")
+  (save-excursion
+    ;; Move begin point to start of line.
+    (goto-char begin)
+    (setq begin (line-beginning-position))
+    ;; Make end a marker, to track updates made in buffer.  Point the
+    ;; marker at the end of the last line.
+    (goto-char end)
+    (setq end (set-marker (make-marker) (line-end-position)))
+    ;; Starting with i = 1, check if there is at least one line in
+    ;; region that has at least i occurrences of regexp.  If so, align
+    ;; i'th occurrence with align-string.  Otherwise, terminate.
+    (let ((i 1)
+	  (i-occurrences-p t))
+      (while i-occurrences-p
+	;; Check that at least one line in region has i occurrences
+	(setq i-occurrences-p nil)
+	(goto-char begin)
+	(while (and (< (point) end)
+		    (not i-occurrences-p))
+	   (when (re-search-forward regexp (line-end-position) t i)
+	     (setq i-occurrences-p t))
+	   (beginning-of-line 2))
+	;; Perform alignment if neccessary.
+	(when i-occurrences-p
+	  (align-string begin end regexp i)
+	  (setq i (1+ i)))))
+    ;; Clear end marker.
+    (set-marker end nil)))
+
+;;; align-string.el ends here
diff -urNad /home/psg/emacs/emacs-goodies-el/emacs-goodies-el/elisp/emacs-goodies-el/cyclebuffer.el emacs-goodies-el/elisp/emacs-goodies-el/cyclebuffer.el
--- /home/psg/emacs/emacs-goodies-el/emacs-goodies-el/elisp/emacs-goodies-el/cyclebuffer.el	2003-06-14 22:35:27.000000000 -0400
+++ emacs-goodies-el/elisp/emacs-goodies-el/cyclebuffer.el	2003-06-15 21:15:10.000000000 -0400
@@ -105,3 +105,5 @@
 visited buffers."
   (interactive)
   (cyclebuffer-forward -1))
+
+(provide 'cyclebuffer)
diff -urNad /home/psg/emacs/emacs-goodies-el/emacs-goodies-el/elisp/emacs-goodies-el/cyclebuffer.el.~1.1.1.1.~ emacs-goodies-el/elisp/emacs-goodies-el/cyclebuffer.el.~1.1.1.1.~
--- /home/psg/emacs/emacs-goodies-el/emacs-goodies-el/elisp/emacs-goodies-el/cyclebuffer.el.~1.1.1.1.~	1969-12-31 19:00:00.000000000 -0500
+++ emacs-goodies-el/elisp/emacs-goodies-el/cyclebuffer.el.~1.1.1.1.~	2003-06-14 22:35:27.000000000 -0400
@@ -0,0 +1,107 @@
+;;; cyclebuffer.el --- select buffer by cycling through
+
+;;; Commentary:
+
+;; Description:
+;; ------------
+;; Cyclebuffer is yet another way of selecting buffers.  Instead of
+;; prompting you for a buffer name, cyclebuffer-forward switches to the
+;; most recently used buffer, and repeated invocations of
+;; cyclebuffer-forward switch to less recently visited buffers.  If you
+;; accidentally overshoot, calling cyclebuffer-backward goes back.  
+;;
+;; I find this to be the fastest buffer-switching mechanism; it`s like C-x
+;; b <return> w/out the return, but it`s not limited to the most recently
+;; accessed buffer.  Plus you never have to remember buffer names; you
+;; just keep cycling until you recognize the buffer you`re searching for.
+
+;; Installation:
+;; -------------
+;;   Add these lines in your .emacs:
+;;     (autoload `cyclebuffer-forward "cyclebuffer" "cycle forward" t)
+;;     (autoload `cyclebuffer-backward "cyclebuffer" "cycle backward" t)
+;;     (global-set-key "M-N" `cyclebuffer-forward)
+;;     (global-set-key "M-P" `cyclebuffer-backward)
+;;
+;;   You may want to adjust the keyboard bindings to avoid conflicts with
+;;   whatever other packages you`re using...
+
+;;
+;; Change History:
+;;	18 Feb 98 v1.2 Bug fixes, code simplification.
+;;
+;; Thanks to Henry Harpending for suggestions.
+;;
+;; Author: Kurt Partridge <kepart@cs.washington.edu>
+;; Maintainer: Kurt Partridge <kepart@cs.washington.edu>
+;; Created: 05 June 1996
+;; Version: $Revision: 1.1 $
+;; Keywords: switch-to-buffer
+
+;; LCD Archive Entry:
+;; cyclebuffer|Kurt Partridge|kepart@cs.washington.edu|
+;; Select buffers by cycling.|
+;; 18-Feb-98|Version 1.2|
+
+;; Copyright (C) 1996 Kurt Partridge
+
+;; This program is free software; you can redistribute it and/or modify
+;; it under the terms of the GNU General Public License as published by
+;; the Free Software Foundation; either version 2, or (at your option)
+;; any later version.
+
+;; This program is distributed in the hope that it will be useful,
+;; but WITHOUT ANY WARRANTY; without even the implied warranty of
+;; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+;; GNU General Public License for more details.
+
+;; You should have received a copy of the GNU General Public License
+;; along with GNU Emacs; see the file COPYING.  If not, write to
+;; the Free Software Foundation, 675 Massachusettes Ave,
+;; Cambridge, MA 02139, USA.
+
+(defvar cyclebuffer-buffer-list nil
+  "List of all buffers; updated every time a new set of cyclebuffer
+commands are started.")
+
+(defvar cyclebuffer-buffer-index nil
+  "Number indicating the index of the buffer in
+cyclebuffer-buffer-list that is currently being displayed.")
+
+(defun cyclebuffer-forward (&optional direction)
+  "Like switch-to-buffer, but doesn`t prompt.  Repetitive invocations of
+this function select progressively less recently visited buffers."
+  (interactive "P")
+  ;; If starting a new search, a) make sure the current buffer is at top
+  ;; of the list of buffers, and b) set flag to generate a new list
+  (if (not (or (eq `cyclebuffer-forward last-command)
+	       (eq `cyclebuffer-backward last-command)))
+      (progn
+	(setq cyclebuffer-buffer-index nil)
+	(switch-to-buffer (current-buffer))))
+  ;; Generate new list if necessary
+  (if (not (numberp cyclebuffer-buffer-index))
+      (progn
+	(setq cyclebuffer-buffer-list (buffer-list))
+	(setq cyclebuffer-buffer-index 0)))
+  ;; Cycle through buffers, skipping any invisible buffers (whose
+  ;; names start with a blank space)
+  (let ((start-buffer (current-buffer))
+	(chosen-buffer (current-buffer)))
+    (while (or (eq chosen-buffer start-buffer)
+	       (char-equal ?  (string-to-char (buffer-name chosen-buffer))))
+      (setq start-buffer nil)
+      (if (or (null direction) (eq direction 1))
+	  (setq cyclebuffer-buffer-index (+ cyclebuffer-buffer-index 1))
+	(setq cyclebuffer-buffer-index (- cyclebuffer-buffer-index 1)))
+      (setq cyclebuffer-buffer-index 
+	    (mod cyclebuffer-buffer-index (length cyclebuffer-buffer-list)))
+      (setq chosen-buffer (nth cyclebuffer-buffer-index
+cyclebuffer-buffer-list)))
+    (switch-to-buffer chosen-buffer)))
+
+(defun cyclebuffer-backward ()
+  "Like cyclebuffer-forward, but selects progressively more recently
+visited buffers."
+  (interactive)
+  (cyclebuffer-forward -1))
diff -urNad /home/psg/emacs/emacs-goodies-el/emacs-goodies-el/elisp/emacs-goodies-el/under.el emacs-goodies-el/elisp/emacs-goodies-el/under.el
--- /home/psg/emacs/emacs-goodies-el/emacs-goodies-el/elisp/emacs-goodies-el/under.el	2003-06-14 22:35:32.000000000 -0400
+++ emacs-goodies-el/elisp/emacs-goodies-el/under.el	2003-06-15 21:14:20.000000000 -0400
@@ -46,3 +46,5 @@
   (newline) 
   (insert-char (string-to-char " ") num-of-chars)
   (insert-char ?^ (abs (- position_deux position_un))))
+
+(provide 'under)
diff -urNad /home/psg/emacs/emacs-goodies-el/emacs-goodies-el/elisp/emacs-goodies-el/under.el.~1.1.1.1.~ emacs-goodies-el/elisp/emacs-goodies-el/under.el.~1.1.1.1.~
--- /home/psg/emacs/emacs-goodies-el/emacs-goodies-el/elisp/emacs-goodies-el/under.el.~1.1.1.1.~	1969-12-31 19:00:00.000000000 -0500
+++ emacs-goodies-el/elisp/emacs-goodies-el/under.el.~1.1.1.1.~	2003-06-14 22:35:32.000000000 -0400
@@ -0,0 +1,48 @@
+;; This file is *NOT* part of GNU Emacs.
+
+;;;  $Id: 9_missing_provide.dpatch,v 1.1 2003/06/16 01:18:56 psg Exp $
+
+;; Copyright (C) 1998 by Benjamin Drieu
+;; Author:	 Benjamin Drieu <bdrieu@april.org>
+;; Maintainer:	 Benjamin Drieu <bdrieu@april.org>
+;; Created:	 1998-08-28
+;; Keywords: convenience
+
+;; LCD Archive Entry:
+;; under|Benjamin Drieu|bdrieu@april.org|
+;; Underline portions of a buffer with "^"|
+;; 1998|$Revision: 1.1 $|~/misc/under.el|
+
+;; This program is free software; you can redistribute it and/or
+;; modify it under the terms of the GNU General Public License as
+;; published by the Free Software Foundation; either version 2, or (at
+;; your option) any later version.
+
+;; This program is distributed in the hope that it will be useful, but
+;; WITHOUT ANY WARRANTY; without even the implied warranty of
+;; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+;; General Public License for more details.
+
+;; You should have received a copy of the GNU General Public License
+;; along with this program; see the file COPYING.  If not, write to
+;; the Free Software Foundation, Inc., 59 Temple Place - Suite 330,
+;; Boston, MA 02111-1307, USA.
+
+
+;;;  Add the following in your .emacs, and do a C-c C-u everywhere to
+;;;  underline the region with "^"
+;;;
+;;;  (autoload 'underline-region "under" "Underline the region" t)
+;;;  (global-set-key "\C-c\C-u" 'underline-region)
+
+(defun underline-region ()
+  "Underline the region"
+  (interactive)  
+  (setq position_un (point))
+  (setq position_deux (mark))
+  (beginning-of-line)
+  (setq num-of-chars (- (min position_un position_deux) (point)))
+  (end-of-line)
+  (newline) 
+  (insert-char (string-to-char " ") num-of-chars)
+  (insert-char ?^ (abs (- position_deux position_un))))
